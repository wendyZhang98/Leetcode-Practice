### Link:
# https://github.com/doocs/leetcode/blob/main/solution/0100-0199/0120.Triangle/README.md


### Description:
# 给定一个三角形 triangle ，找出自顶向下的最小路径和。
# 每一步只能移动到下一行中相邻的结点上。
# 相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。
# 也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

## 进阶：
# 你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？


### Example:
# 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
# 输出：11
# 解释：如下面简图所示：
#    "2"
#   "3" 4
#  6 "5" 7
# 4 "1" 8 3
# 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）


### Solution:
# https://leetcode-cn.com/problems/triangle/solution/san-jiao-xing-zui-xiao-lu-jing-he-by-leetcode-solu/

# 本题是一道非常经典且历史悠久的动态规划题，
# 其作为算法题出现，最早可以追溯到 1994 年的 IOI（国际信息学奥林匹克竞赛）的 The Triangle
# 时光飞逝，经过 20 多年的沉淀，往日的国际竞赛题如今已经变成了动态规划的入门必做题，不断督促着我们学习和巩固算法。

# 在本题中，给定的三角形的行数为 nn，并且第 ii 行（从 00 开始编号）包含了 i+1i+1 个数。
# 如果将每一行的左端对齐，那么会形成一个等腰直角三角形，如下所示：

# 方法一：动态规划
# 我们用 f[i][j] 表示从三角形顶部走到位置 (i, j) 的最小路径和。
# 这里的位置 (i, j) 指的是三角形中第 i 行第 j 列（均从 00 开始编号）的位置。

# 由于每一步只能移动到下一行「相邻的节点」上，
# 因此要想走到位置 (i, j), 上一步就只能在位置 (i - 1, j - 1) 或者位置 (i - 1, j)
# 我们在这两个位置中选择一个路径和较小的来进行转移，

# 状态转移方程为：
# f[i][j] = min(f[i-1][j-1], f[i-1][j]) + c[i][j]
# f[i][j]= min(f[i−1][j−1],f[i−1][j]) + c[i][j]
# 其中 c[i][j] 表示位置 (i, j) 对应的元素值。

# 注意第 i 行有 i+1 个元素，它们对应的 j 的范围为 [0, i]。
# 当 j=0 或 j=i 时，上述状态转移方程中有一些项是没有意义的。
# 例如当 j=0 时，f[i-1][j−1] 没有意义，因此状态转移方程为：
# f[i][0] = f[i-1][0] + c[i][0]
# 即当我们在第 i 行的最左侧时，我们只能从第 i-1 行的最左侧移动过来。

# 当 j=i 时，f[i-1][j] 没有意义，因此状态转移方程为：
# f[i][i] = f[i-1][i-1] + c[i][i]
# 即当我们在第 i 行的最右侧时，我们只能从第 i-1 行的最右侧移动过来。

# 最终的答案即为 f[n-1][0] 到 f[n-1][n−1] 中的最小值，其中 nn 是三角形的行数。

# 状态转移方程的边界条件是什么？由于我们已经去除了所有「没有意义」的状态，因此边界条件可以定为：
# f[0][0] = c[0][0]
# 即在三角形的顶部时，最小路径和就等于对应位置的元素值。
# 这样一来，我们从 1 开始递增地枚举 i，并在 [0, i] 的范围内递增地枚举 j，就可以完成所有状态的计算。


class Solution:
    def minimumTotal(self, triangle):
        n = len(triangle)
        f = [[0] * n for _ in range(n)]
        f[0][0] = triangle[0][0]

        for i in range(1, n):
            f[i][0] = f[i - 1][0] + triangle[i][0]
            for j in range(1, i):
                f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]
            f[i][i] = f[i - 1][i - 1] + triangle[i][i]
        return min(f[n - 1])
